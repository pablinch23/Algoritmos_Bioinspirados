# ----------------------------- Metadatos y referencias -----------------------------
# Python code of Gravitational Search Algorithm (GSA)
# Reference: Rashedi, Esmat, Hossein Nezamabadi-Pour, and Saeid Saryazdi. 
#            "GSA: a gravitational search algorithm." Information sciences 179.13 (2009): 2232-2248.
# Coded by: Mukesh Saraswat, Himanshu Mittal y Raju Pal (emails en cabecera original)
# Este archivo es el principal del algoritmo GSA para minimizar una funci贸n objetivo.

import numpy as np                           # Importa NumPy para c谩lculos num茅ricos y manejo de arreglos
import matplotlib.pyplot as plt              # Importa Matplotlib para graficar resultados
import seaborn as sns                        # Importa Seaborn para gr谩ficos estad铆sticos (heatmap)
from sklearn.datasets import load_breast_cancer        # Carga un dataset de c谩ncer de mama de scikit-learn
from sklearn.model_selection import train_test_split   # Funci贸n para dividir datos en entrenamiento y prueba
from sklearn.neighbors import KNeighborsClassifier     # Importa el clasificador k-NN
from sklearn.metrics import accuracy_score             # M茅trica de precisi贸n para evaluar el modelo
from sklearn.decomposition import PCA                  # PCA para reducci贸n de dimensi贸n en animaci贸n
from matplotlib.animation import FuncAnimation, PillowWriter  # Para crear y guardar animaciones GIF

# ==============================
# Cargar dataset
# ==============================
data = load_breast_cancer()                # Carga el dataset y lo guarda en la variable `data`
X_data = data.data                         # Extrae las caracter铆sticas (matriz n_samples  n_features)
y_data = data.target                       # Extrae las etiquetas (vector de clases)
num_features = X_data.shape[1]             # Calcula cu谩ntas caracter铆sticas hay (dimensi贸n)

# Divide los datos en conjunto de entrenamiento (70%) y prueba (30%), con semilla fija
X_train, X_test, y_train, y_test = train_test_split(
    X_data, y_data, test_size=0.3, random_state=42
)

# ==============================
# Funci贸n de evaluaci贸n
# ==============================
def evaluate_solution(binary_vector):
    """
    Eval煤a un agente (vector binario) entrenando k-NN
    con las caracter铆sticas seleccionadas y mide precisi贸n.
    """
    if np.count_nonzero(binary_vector) == 0:
        return 1.0                      # Si no selecciona ninguna caracter铆stica, retorna peor fitness

    selected = np.where(binary_vector == 1)[0]  # ndices de caracter铆sticas marcadas con 1
    clf = KNeighborsClassifier(n_neighbors=5)  # Crea un clasificador k-NN con k=5
    clf.fit(X_train[:, selected], y_train)     # Entrena el clasificador solo con caracter铆sticas seleccionadas
    pred = clf.predict(X_test[:, selected])    # Predice sobre el conjunto de prueba
    acc = accuracy_score(y_test, pred)         # Calcula la precisi贸n del clasificador

    penalty = np.count_nonzero(binary_vector) / len(binary_vector)  
    # Penaliza soluciones que usan muchas caracter铆sticas
    return 1.0 - (acc - 0.01 * penalty)        # Return fitness: cuanto menor, mejor

# ==============================
# Algoritmo GSA con animaci贸n
# ==============================
def GSA_feature_selection(num_agents=30, max_iter=40, dim=num_features):
    # Inicializa posiciones binarias de agentes y velocidades
    X = np.random.randint(0, 2, (num_agents, dim))  # Poblaci贸n: matriz (agentes  caracter铆sticas)
    V = np.zeros((num_agents, dim))                 # Velocidades iniciales = 0

    best_fitness = float('inf')          # Mejor fitness encontrado (infinito al inicio)
    best_position = None                 # Mejor posici贸n (vector) hasta ahora

    history_fitness = []                 # Historial de mejor fitness por iteraci贸n
    history_num_features = []            # Historial de cu谩ntas caracter铆sticas usa la mejor posici贸n
    feature_selection_counter = np.zeros(dim)  
    # Contador de cu谩ntas veces cada caracter铆stica fue seleccionada en el mejor global
    all_positions = []                   # Guarda todas las posiciones para la animaci贸n

    for t in range(max_iter):            # Bucle principal por n煤mero de iteraciones
        fitness = np.array([evaluate_solution(agent) for agent in X])
        # Calcula fitness de cada agente en la poblaci贸n

        best = np.min(fitness)           # Fitness m谩s bajo (mejor) de la iteraci贸n
        worst = np.max(fitness)          # Fitness m谩s alto (peor) de la iteraci贸n

        if best < best_fitness:          # Si se mejora el mejor global
            best_fitness = best
            best_position = X[np.argmin(fitness)].copy()  
            # Actualiza la mejor posici贸n global

        eps = 1e-20                       # Epsilon para evitar divisiones por cero
        m = (fitness - worst) / (best - worst + eps)  
        # Calcula masa relativa de cada agente
        M = m / (np.sum(m) + eps)        # Normaliza masas para que sumen 1

        G = 100 * np.exp(-20 * t / max_iter)  
        # Calcula constante gravitacional decreciente

        a = np.zeros((num_agents, dim))  # Aceleraciones vac铆as
        for i in range(num_agents):      # Para cada agente i
            total_force = np.zeros(dim)
            for j in range(num_agents):  # Para cada agente ji
                if i != j:
                    R = np.linalg.norm(X[i] - X[j])  
                    # Distancia Euclidiana entre agentes i y j
                    force = G * M[i] * M[j] * (X[j] - X[i]) / (R + eps)
                    # Ley de gravitaci贸n modificada en espacio binario
                    total_force += np.random.rand() * force  
                    # Aleatoriza contribuci贸n de la fuerza
            a[i] = total_force / (M[i] + eps)  
            # Aceleraci贸n proporcional a la masa del agente

        V = np.random.rand(num_agents, dim) * V + a  
        # Actualiza velocidades con componente aleatorio
        S = 1 / (1 + np.exp(-V))               
        # Funci贸n sigmoide para convertir velocidades a probabilidades
        X = (S > np.random.rand(num_agents, dim)).astype(int)  
        # Nuevas posiciones: 1 si probabilidad > aleatorio, 0 si no

        feature_selection_counter += np.sum(X, axis=0)  
        # Actualiza contador de cu谩ntas veces cada caracter铆stica aparece
        history_fitness.append(best_fitness)  
        history_num_features.append(np.count_nonzero(best_position))
        all_positions.append(X.copy())  
        # Guarda estados para graficar y animar

        print(f"Iteraci贸n {t+1}/{max_iter} | Mejor fitness: {best_fitness:.4f} | Caracter铆sticas: {np.count_nonzero(best_position)}")

    return best_position, 1.0 - best_fitness, history_fitness, history_num_features, feature_selection_counter, all_positions
    # Devuelve: mejor subconjunto, precisi贸n asociada, historiales y datos de animaci贸n

# ==============================
# Ejecutar y graficar
# ==============================
if __name__ == "__main__":
    # Llama al algoritmo con par谩metros por defecto
    best_subset, best_acc, fitness_hist, feature_hist, feature_usage, all_positions = GSA_feature_selection()

    selected = np.where(best_subset == 1)[0]  # ndices de caracter铆sticas finalmente seleccionadas

    # Imprime resultados finales en consola
    print("\n===== RESULTADOS =====")
    print(f"Accuracy final: {best_acc:.4f}")
    print(f"N煤mero de caracter铆sticas seleccionadas: {len(selected)}")
    print(f"ndices seleccionados: {selected}")

    # 1. Graficar evoluci贸n del fitness
    plt.figure()
    plt.plot(fitness_hist, marker='o')
    plt.title("Mejor fitness por iteraci贸n")
    plt.xlabel("Iteraci贸n")
    plt.ylabel("Fitness (menor es mejor)")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    # 2. Graficar n煤mero de caracter铆sticas de la mejor soluci贸n
    plt.figure()
    plt.plot(feature_hist, marker='s', color='orange')
    plt.title("N煤mero de caracter铆sticas seleccionadas por iteraci贸n")
    plt.xlabel("Iteraci贸n")
    plt.ylabel("Caracter铆sticas seleccionadas")
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    # 3. Heatmap de frecuencia de uso de cada caracter铆stica
    plt.figure(figsize=(10, 2))
    sns.heatmap(
        [feature_usage],
        cmap="YlGnBu",
        cbar=True,
        xticklabels=[f'F{i}' for i in range(num_features)],
        yticklabels=['Uso']
    )
    plt.title("Frecuencia de uso de cada caracter铆stica")
    plt.xlabel("Caracter铆sticas")
    plt.tight_layout()
    plt.show()

    # 4. Crear y guardar animaci贸n GIF del movimiento de part铆culas
    fig, ax = plt.subplots(figsize=(7, 6))
    pca = PCA(n_components=2)  # Reduce posiciones a 2D para visualizar

    def update(frame):
        ax.clear()
        reduced = pca.fit_transform(all_positions[frame])
        ax.scatter(reduced[:, 0], reduced[:, 1], c='purple', alpha=0.6, s=30)
        ax.set_title(f"Movimiento de part铆culas (Iteraci贸n {frame + 1})")
        ax.set_xlabel("PCA 1")
        ax.set_ylabel("PCA 2")
        ax.grid(True)

    anim = FuncAnimation(fig, update, frames=len(all_positions), interval=500)
    anim.save("gsa_movimiento.gif", writer=PillowWriter(fps=2))
    print(" Animaci贸n guardada como 'gsa_movimiento.gif'")
